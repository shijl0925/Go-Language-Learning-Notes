# 内置库的常用操作

* strings
* bytes
* json
* io/bufio
* strconv
* fmt
* time
* regexp
* reflect/unsafe
* os/path/filepath
* unicode
* Sort



# strings

1. 前缀和后缀

  * `HasPrefix()` 判断字符串`s`是否以`prefix`开头：

    ``````go
    strings.HasPrefix(s, prefix string) bool
    ``````

  * `HasSuffix()`判断字符串`s`是否以`suffix`结尾：

    ```go
    strings.HasSuffix(s, suffix string) bool



2. 字符串包含关系

* `Contains()`判断字符串`s`是否包含`substr`

  ``````go
  strings.Contains(s, substr string) bool
  ``````



3. 判断子字符串或字符在父字符串中出现的位置（索引）

* `Index()`返回字符串`str`在字符串`s`中的索引（`str`的第一个字符的索引），-1表示字符串`s`不包含字符串`str`:

  ``````go
  strings.Index(s, str string) int
  ``````

* `LastIndex()`返回字符串`str`在字符串`s`中最后出现的位置的索引（`str`的第一个字符的索引），-1表示字符串`s`不包含字符串`str`:

  ``````go
  strings.LastIndex(s, str string) int
  ``````
* `IndexRune` 查询非ASCII编码的字符在父字符串中的位置

  ```go
  strings.IndexRune(s string, r rune) int
  ```



4. 字符串替换

* `Replace()`用于将字符串`str`中前`n`个字符串`old`替换为字符串`new`，并返回一个新的字符串，如果`n = -1`则替换所有的字符串`old`为字符串`new`

  ```go
  strings.Replace(str, old, new string, n int) string
  ```



5. 统计字符串出现的次数

* `Count()`用于计算字符串`str`在字符串`s`中出现的非重叠次数：

  ```go
  strings.Count(s, str string) int
  ```



6. 重复字符串

* `Repeat()`用于重复`ount`次字符串`s`并返回一个新的字符串：

  ```go
  strings.Repeat(s string, count int) string
  ```



7. 修改字符串大小写

* `ToLower()`将字符串中的Unicode字符全部转化为相应的小写字符：

  ```go
  strings.ToLower(s) string
  ```

* `ToUpper()`将字符串中的Unicode字符全部转化为相应的大写字符：

  ```go
  strings.ToUpper(s) string
  ```



8. 修剪字符串

* `strings.TrimSpace(s)`剔除字符串中开头和结尾的空白符。
* `strings.Trim(s, "cut")将`字符串`s`中开头和结尾的`cut`去除掉。第二个参数可以包含任何字符。
* 如果只想剔除开头或者结尾的字符串，使用`strings.TrimLeft` 或者`strings.TrimRight` 来实现。



9. 分割字符串

* `strings.Fields(s)` 将会利用1个或多个空白符来作为动态长度的分隔符将字符串分割成若干个小块，并返回一个 slice。

  ```go
  str := "The quick brown fox jumps over the lazy dog"
  sl := strings.Fields(str)
  
  for _, val := range(sl) {
    fmt.Printf("%s - ", val)
  }
  ```



* `strings.Split(s, sep)`用于使用自定义分割符号来对指定字符串进行分割，同样返回slice。

  ```go
  str := "GO1|GO2|GO3"
  sl := strings.Split(str, "|")
  for _, val := range(sl) {
    fmt.Printf("%s - ", val)
  }
  ```



10. 拼接slice到字符串

* `strings.Join()`用于将元素类型为string的 slice 使用分隔符号来拼接组成一个字符串。

  ```go
  strings.Join(sl []string, sep string) string
  ```

  ```go
  sl = []string{"a", "b", "c", "d"}
  str := strings.Join(sl, ";")
  fmt.Printf("sl joined by ;: %s\n", str)
  ```



11. 从字符串中读取内容

* `strings.NewReader(str)`用于生成一个`Reader`并读取字符串中的内容，然后返回指向该`Reader`的指针。

* `Read()`从`[]byte`中读取内容。

  ```go
  // Len(): 返回未读的字符串长度
  // Size():返回字符串的长度
  // Read(): 读取字符串信息

  r := strings.NewReader("abcdefghijklmn")
  fmt.Println(r.Len())   // 输出14  初始时，未读长度等于字符串长度

  var buf []byte
  buf = make([]byte, 5)
  readLen, err := r.Read(buf)
  fmt.Println("读取到的长度:", readLen) //读取到的长度5
  if err != nil {
  	fmt.Println("错误:", err)
  }

  fmt.Println(buf)            //abcde
  fmt.Println(r.Len())        //9   读取到了5个 剩余未读是14-5
  fmt.Println(r.Size())       //14   字符串的长度
  ```

* `ReadAt()` 读取偏移off字节后的剩余信息到b中（需要注意的是，ReadAt函数不会影响Len的数值，和Read的数值，off不能为负数，不能大于size（）的长度）

  ```go
  func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
  ```

  ```go
  r := strings.NewReader("abcdefghijklmn")
   
  var bufAt []byte
  bufAt = make([]byte, 256)
  r.ReadAt(bufAt, 5)
  fmt.Println(string(bufAt))              //fghijklmn
  ```


* `ReadByte()`和`ReadRune()`从字符串中读取下一个`byte`或者`rune`。

  ```go
  r := strings.NewReader("abcdefghijklmn")
  	
  //读取一个字节
  b, _ := r.ReadByte()
  fmt.Println(string(b))					// a
  //int(r.Size()) - r.Len() 已读取字节数
  fmt.Println(int(r.Size()) - r.Len())	// 1
   
  //读取一个字节
  b, _ = r.ReadByte()
  fmt.Println(string(b))					// b
  fmt.Println(int(r.Size()) - r.Len())	// 2
   
  //回退一个字节
  r.UnreadByte()
  fmt.Println(int(r.Size()) - r.Len())	// 1
   
  //读取一个字节
  b, _ = r.ReadByte()
  fmt.Println(string(b))					// b
  ```

* `Seek()` 前面有ReadAt方法可以将字符串偏移多少位读取剩下的字符串内容，但是该方法不会影响正在用Read方法读取的内容，如果相对Read方法读取的内容做偏移就可以使用seek方法， offset是偏移的位置，whence是偏移起始位置，支持三种位置（io.SeekStart起始位，io.SeekCurrent当前位，io.SeekEnd末位）。需要注意的是offset可以未负数，当时偏移起始位 与offset相加得到的值不能小于0或者大于size()的长度

  `func (r *Reader) Seek(offset int64, whence int) (int64, error)`
  
  ```go
  r := strings.NewReader("abcdefghijklmn")
   
  var buf []byte
  buf = make([]byte, 5)
  r.Read(buf)
  fmt.Println(string(buf)) //adcde
   
  buf = make([]byte, 5)
  r.Seek(-2, io.SeekCurrent) //从当前位置向前偏移两位 （5-2)
  r.Read(buf)
  fmt.Println(string(buf)) //defgh
  	
  buf = make([]byte, 5)
  r.Seek(-3, io.SeekEnd) //设置当前位置是末尾前移三位
  r.Read(buf)
  fmt.Println(string(buf)) //lmn
   
  buf = make([]byte, 5)
  r.Seek(3, io.SeekStart) //设置当前位置是起始位后移三位
  r.Read(buf)
  fmt.Println(string(buf)) //defgh
  ```
  
  
